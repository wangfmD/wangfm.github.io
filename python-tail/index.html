<html>
    <head>

        <meta http-equiv="content-type" content="text/html; charset=utf-8" />
        <link href="../static/css/main.css" rel="stylesheet" type="text/css">
        <title>Python尾递归优化</title>
    </head>
    <body>
        <h2>一般递归与尾递归</h2>
<h4>一般递归:</h4>
<div class="codehilite"><pre>def normal_recursion(n):
    if n == 1:
        return 1
    else:
        return n + normal_recursion(n-1)
</pre></div>


<p>执行：</p>
<div class="codehilite"><pre>normal_recursion(5)
5 + normal_recursion(4)
5 + 4 + normal_recursion(3)
5 + 4 + 3 + normal_recursion(2)
5 + 4 + 3 + 2 + normal_recursion(1)
5 + 4 + 3 + 2 + 1
15
</pre></div>


<p><strong>一般递归</strong>的效率是比较低的，因为在<code>return n + normal_recursion(n-1)</code>时需要
调用栈保存中间变量n的值，递归进行的越深入，需要调用的栈就越多，效率也就越低。<br/></p>
<h4>尾递归</h4>
<p>如果可以将中间变量作为参数直接传递给递归调用函数，那么可以大大提高递归效率，这就是尾递归
的实现</p>
<div class="codehilite"><pre>def tail_recursion(n, total=0):
    if n == 0:
        return total
    else:
        return tail_recursion(n-1, total+n)
</pre></div>


<p>执行：</p>
<div class="codehilite"><pre>tail_recursion(5)
tail_recursion(4, 5)
tail_recursion(3, 9)
tail_recursion(2, 12)
tail_recursion(1, 14)
tail_recursion(0, 15)
15
</pre></div>


<h2>存在的问题</h2>
<p>python 本身对尾递归的支持不太好，当递归深度超过1000时会报错</p>
<div class="codehilite"><pre><span class="n">RuntimeError</span><span class="o">:</span> <span class="n">maximum</span> <span class="n">recursion</span> <span class="n">depth</span> <span class="n">exceeded</span>
</pre></div>


<h2>一个牛人想出的解决办法：</h2>
<h4>实现一个 tail_call_optimized 装饰器</h4>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64</pre></div></td><td class="code"><div class="codehilite"><pre><span class="ch">#!/usr/bin/env python2.4</span>
<span class="c1"># This program shows off a python decorator(</span>
<span class="c1"># which implements tail call optimization. It</span>
<span class="c1"># does this by throwing an exception if it is</span>
<span class="c1"># it&#39;s own grandparent, and catching such</span>
<span class="c1"># exceptions to recall the stack.</span>
<span class="c1"># 抛出异常，捕获异常，重新调用栈...牛</span>

<span class="kn">import</span> <span class="nn">sys</span>

<span class="k">class</span> <span class="nc">TailRecurseException</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;尾递归异常类&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">args</span> <span class="o">=</span> <span class="n">args</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span> <span class="o">=</span> <span class="n">kwargs</span>

<span class="k">def</span> <span class="nf">tail_call_optimized</span><span class="p">(</span><span class="n">g</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function decorates a function with tail call</span>
<span class="sd">    optimization. It does this by throwing an exception</span>
<span class="sd">    if it is it&#39;s own grandparent, and catching such</span>
<span class="sd">    exceptions to fake the tail call optimization.</span>

<span class="sd">    This function fails if the decorated</span>
<span class="sd">    function recurses in a non-tail context.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">_getframe</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="n">f_back</span> <span class="ow">and</span> <span class="n">f</span><span class="o">.</span><span class="n">f_back</span><span class="o">.</span><span class="n">f_back</span> \
            <span class="ow">and</span> <span class="n">f</span><span class="o">.</span><span class="n">f_back</span><span class="o">.</span><span class="n">f_back</span><span class="o">.</span><span class="n">f_code</span> <span class="o">==</span> <span class="n">f</span><span class="o">.</span><span class="n">f_code</span><span class="p">:</span>
            <span class="c1"># 抛出异常</span>
            <span class="k">raise</span> <span class="n">TailRecurseException</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">g</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="k">except</span> <span class="n">TailRecurseException</span><span class="p">,</span> <span class="n">e</span><span class="p">:</span>
                    <span class="c1"># 捕获异常，重新调用栈</span>
                    <span class="n">args</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">args</span>
                    <span class="n">kwargs</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">kwargs</span>
    <span class="n">func</span><span class="o">.</span><span class="n">__doc__</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">__doc__</span>
    <span class="k">return</span> <span class="n">func</span>

<span class="nd">@tail_call_optimized</span>
<span class="k">def</span> <span class="nf">factorial</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">acc</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="s2">&quot;calculate a factorial&quot;</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">acc</span>
    <span class="k">return</span> <span class="n">factorial</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="o">*</span><span class="n">acc</span><span class="p">)</span>

<span class="k">print</span> <span class="n">factorial</span><span class="p">(</span><span class="mi">10000</span><span class="p">)</span>
<span class="c1"># prints a big, big number,</span>
<span class="c1"># but doesn&#39;t hit the recursion limit.</span>

<span class="nd">@tail_call_optimized</span>
<span class="k">def</span> <span class="nf">fib</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">current</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">next</span> <span class="o">=</span> <span class="mi">1</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">current</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">fib</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">next</span><span class="p">,</span> <span class="n">current</span> <span class="o">+</span> <span class="nb">next</span><span class="p">)</span>

<span class="k">print</span> <span class="n">fib</span><span class="p">(</span><span class="mi">10000</span><span class="p">)</span>
<span class="c1"># also prints a big number,</span>
<span class="c1"># but doesn&#39;t hit the recursion limit.</span>
</pre></div>
</td></tr></table>

<p>作者的基本思想就是当尾递归达到最大深度时自己抛出一个异常(TailRecurseException), 然后
捕获这个异常，然后重新调用栈，而不是让异常终止尾递归的运行。<br/></p>
<p>这里解释一下 sys._getframe() 函数:<br/></p>
<div class="codehilite"><pre><span class="n">sys</span><span class="o">.</span><span class="n">getframe</span><span class="p">([</span><span class="n">depth</span><span class="p">]):</span>
<span class="n">Return</span> <span class="n">a</span> <span class="n">frame</span> <span class="nb">object</span> <span class="kn">from</span> <span class="nn">the</span> <span class="nn">call</span> <span class="nn">stack.</span> <span class="nn">If</span> <span class="nn">optional</span> <span class="nn">integer</span> <span class="nn">depth</span> <span class="nn">is</span> <span class="nn">given</span><span class="p">,</span> <span class="k">return</span> <span class="n">the</span> <span class="n">frame</span> <span class="nb">object</span> <span class="n">that</span> <span class="n">many</span> <span class="n">calls</span> <span class="n">below</span> <span class="n">the</span> <span class="n">top</span> <span class="n">of</span> <span class="n">the</span> <span class="n">stack</span><span class="o">.</span> <span class="n">If</span> <span class="n">that</span> <span class="ow">is</span> <span class="n">deeper</span> <span class="n">than</span> <span class="n">the</span> <span class="n">call</span> <span class="n">stack</span><span class="p">,</span> <span class="ne">ValueError</span> <span class="ow">is</span> <span class="n">raised</span><span class="o">.</span> <span class="n">The</span> <span class="n">default</span> <span class="k">for</span> <span class="n">depth</span> <span class="ow">is</span> <span class="n">zero</span><span class="p">,</span> <span class="n">returning</span> <span class="n">the</span> <span class="n">frame</span> <span class="n">at</span> <span class="n">the</span> <span class="n">top</span> <span class="n">of</span> <span class="n">the</span> <span class="n">call</span> <span class="n">stack</span><span class="o">.</span>

<span class="err">即返回</span><span class="n">depth</span><span class="err">深度调用的栈帧对象</span><span class="o">.</span>

<span class="kn">import</span> <span class="nn">sys</span>

<span class="k">def</span> <span class="nf">get_cur_info</span><span class="p">():</span>
    <span class="k">print</span> <span class="n">sys</span><span class="o">.</span><span class="n">_getframe</span><span class="p">()</span><span class="o">.</span><span class="n">f_code</span><span class="o">.</span><span class="n">co_filename</span>  <span class="c1"># 当前文件名</span>
    <span class="k">print</span> <span class="n">sys</span><span class="o">.</span><span class="n">_getframe</span><span class="p">()</span><span class="o">.</span><span class="n">f_code</span><span class="o">.</span><span class="n">co_name</span>  <span class="c1"># 当前函数名</span>
    <span class="k">print</span> <span class="n">sys</span><span class="o">.</span><span class="n">_getframe</span><span class="p">()</span><span class="o">.</span><span class="n">f_lineno</span> <span class="c1"># 当前行号</span>
    <span class="k">print</span> <span class="n">sys</span><span class="o">.</span><span class="n">_getframe</span><span class="p">()</span><span class="o">.</span><span class="n">f_back</span> <span class="c1"># 调用者的帧</span>
</pre></div>


<h2>参考</h2>
<p>http://www.cnblogs.com/hello--the-world/archive/2012/07/19/2599003.html<br/>
http://www.chinaz.com/program/2013/0917/318157_2.shtml</p>
        <div id="disqus_thread"></div>
        <script>
        /**
        * RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
        * LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
        */
        /*
        var disqus_config = function () {
        this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
        };
        */
        (function() { // DON'T EDIT BELOW THIS LINE
        var d = document, s = d.createElement('script');

        s.src = '//neo1218flask.disqus.com/embed.js';

        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
        })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
    </body>
</html>
